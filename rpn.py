# вот здесь вам нужно сделать исполнитель
# на вход он получит список
# например,
[('a', 'ID'), ('b', 'ID'), ('num', 'RESERVED'), ('a', 'ID'), ('3', 'INT'), ('<', 'RESERVED'), ('tag1', 11), ('jf', 'RESERVED'), ('b', 'ID'), ('4', 'INT'), (':=', 'RESERVED')]
первые три это объявления переменных. 
с 4 по 8 начало условия.
('tag1', 11) -- это то куда нужно перейти в польской строке, если ложно
('b', 'ID'), ('4', 'INT'), (':=', 'RESERVED')
переменной b присваивается зачение четыре 
# и далее как это обычно происходит в обратной полськой строке
# здесь [('a', 'ID')] -- это имя переменной при обявлении нужно следить,
# что это простая переменная -- num
# массив -- arr
# двумерный массив -- mtx

# здесь нужно подумать я не до конца уверен, но можно
# сделать так
# хранение переменных в словарях 
# пример для обыковенных переменных
# variables = {'var_name': 4, 'num_lines': 3}

# для массивов создать класс массивов, где будут храниться
# паспорта и значения 

def take_token(tokens): #освновная функция, которой будут обращатся
    a=2
    return a

if __name__ == '__main__': # зедсь можно тестить вызывая python3 rpn.py в консоли
    a = 2